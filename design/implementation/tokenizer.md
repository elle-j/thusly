# Thusly Design - Tokenizer

> üëâÔ∏è These design documents are currently being added to incrementally.

## Table of Contents

- [Abstract](#abstract)
- [Token](#token)
- [Walk-Through of Examples](#walk-through-of-examples)
    - [Example: Arithmetic](#example-arithmetic)

## Abstract

![Thusly architectural overview](../media/thusly-design-architectural-overview-highlight-tokenizer.svg)

The tokenizer generates *tokens* on demand which is controlled by the parser, by advancing through the source code (stored in a string buffer) character-by-character.

It performs lexical analysis to ensure use of valid characters and sequence of characters, and hence also flags any lexical errors encountered.

Since the parser controls when the tokenizer should generate and return the next token, there is no list of all tokens stored and no abstract syntax tree is produced to represent the entire source code.

**Maximum character lookahead:** 2

## Token

A token is the smallest unit to represent a piece of the code used by the parser after being generated by the tokenizer.

Below is a pseudo-code representation of a token containing some of the data stored:

```
Token:
    type: TokenType
    lexeme: String
```

* `type`
  * Examples: `TOKEN_NUMBER`, `TOKEN_PLUS`, `TOKEN_MINUS`
* `lexeme`
  * The exact character sequence the token refers to.
  * Examples: `"1.2"`, `"+"`, `"-"`

## Walk-Through of Examples

These examples demonstrate some of the details of the tokenizer's steps when processing a string containing the code of a source file.

* Examples:
  * [Arithmetic](#example-arithmetic)

### Example: Arithmetic

**Source code:**

```
1.2 + 3 * 4 / -5
```

**Expected tokens:**

![Thusly generated tokens](../media/thusly-design-example-arithmetic-tokens.svg)

**Tokenization process:**

**Token #1** (expected lexeme: `"1.2"`):

```
1.2
^
```

![Thusly tokenizer scanning number](../media/thusly-design-example-arithmetic-scan-number.svg)

1. When the tokenizer scans for a new token, it has a pointer to the `start` of the lexeme and to the `current` character being scanned.
1. When the digit `1` is encountered, it keeps advancing the `current` pointer until a non-digit is found, in this case `.`.
1. Since numbers in Thusly are double-precision floating point numbers, it looks ahead one character to see if it is a `.`, and if so, looks ahead another character to see if it is a digit.
1. The `current` pointer is then advanced until it encounters the whitespace.
1. The token is generated using the characters between `start` and `current` as the lexeme:

    ```
    Token:
        type: TOKEN_NUMBER
        lexeme: "1.2"
    ```

**Token #2** (expected lexeme: `"+"`):

```
1.2 +
    ^
```

1. The `start` and `current` pointers point to `"+"`.
1. Since Thusly supports augmented assignment via the `+:` operator, it looks ahead one character to see if it is a `:`. Since the next character is not a `:`, only `+` is consumed.
1. The token is generated:

    ```
    Token:
        type: TOKEN_PLUS
        lexeme: "+"
    ```

**Token #3** (expected lexeme: `"3"`):

```
1.2 + 3
      ^
```

1. The `start` and `current` pointers point to `"3"`.
1. Only `"3"` is consumed since consuming the next character would not produce a valid number.
1. The token is generated:

    ```
    Token:
        type: TOKEN_NUMBER
        lexeme: "3"
    ```

**Token #4** (expected lexeme: `"*"`):

```
1.2 + 3 *
        ^
```

1. The `start` and `current` pointers point to `"*"`.
1. Since Thusly supports augmented assignment via the `*:` operator, it looks ahead one character to see if it is a `:`. Since the next character is not a `:`, only `*` is consumed.
1. The token is generated:

    ```
    Token:
        type: TOKEN_STAR
        lexeme: "*"
    ```

**Token #5** (expected lexeme: `"4"`):

```
1.2 + 3 * 4
          ^
```

1. The `start` and `current` pointers point to `"4"`.
1. Only `"4"` is consumed since consuming the next character would not produce a valid number.
1. The token is generated:

    ```
    Token:
        type: TOKEN_NUMBER
        lexeme: "4"
    ```

**Token #6** (expected lexeme: `"/"`):

```
1.2 + 3 * 4 /
            ^
```

1. The `start` and `current` pointers point to `"/"`.
1. Since Thusly supports augmented assignment via the `/:` operator, it looks ahead one character to see if it is a `:`. Since the next character is not a `:`, only `/` is consumed.
1. The token is generated:

    ```
    Token:
        type: TOKEN_SLASH
        lexeme: "/"
    ```

**Token #7** (expected lexeme: `"-"`):

```
1.2 + 3 * 4 / -
              ^
```

1. The `start` and `current` pointers point to `"-"`.
1. Since Thusly supports augmented assignment via the `-:` operator, it looks ahead one character to see if it is a `:`. Since the next character is not a `:`, only `-` is consumed.
1. The token is generated:

    ```
    Token:
        type: TOKEN_MINUS
        lexeme: "-"
    ```

**Token #8** (expected lexeme: `"5"`):

```
1.2 + 3 * 4 / -5
               ^
```

1. The `start` and `current` pointers point to `"5"`.
1. Only `"5"` is consumed since consuming the next character would not produce a valid number.
1. The token is generated:

    ```
    Token:
        type: TOKEN_NUMBER
        lexeme: "5"
    ```

**Token #9** (expected lexeme: `"\n"`, newline):

```
1.2 + 3 * 4 / -5
                 ^
```

1. The `start` and `current` pointers point to the newline character.
1. Since the newline is not on a blank line (i.e. a line only containing whitespace and/or comments and/or a newline), the newline is semantically significant and is consumed.
1. The token is generated:

    ```
    Token:
        type: TOKEN_NEWLINE
        lexeme: "\n"
    ```

**Token #10** (expected lexeme: `"\0"`, null byte):

```
1.2 + 3 * 4 / -5
```

1. The `start` and `current` pointers point to the terminating null byte character in the string buffer.
1. Since this signifies the end of the source file, an end-of-file sentinel token is also generated:

    ```
    Token:
        type: TOKEN_EOF
        lexeme: "\0"
    ```
