# Thusly Design - Parser & Compiler

## Table of Contents

- [Abstract](#abstract)
- [Top-Down Operator Precedence Parsing](#top-down-operator-precedence-parsing)
- [Constant Pool](#constant-pool)
- [Walk-Through of Examples](#walk-through-of-examples)
    - [Example: Arithmetic](#example-arithmetic)

## Abstract

![Thusly architectural overview](../media/thusly-design-architectural-overview-highlight-parser.svg)

The parser and the compiler work in tandem to parse the tokens generated by the tokenizer and write the corresponding bytecode instructions in the correct order based on the precedence of the operators used.

The parser performs syntactic analysis to ensure coherence with the specified [grammar](./grammar.txt) as well as semantic analysis and variable resolution.

All steps are performed in a single pass.

## Top-Down Operator Precedence Parsing

The parser parses statements and expressions recursively starting from the top (expressions using lower-precedence operators) to bottom (expressions using higher-precedence operators).

Each production of an expression rule in the Thusly grammar always either calls itself (same-level precedence) or a rule of higher precedence. Thus, it is defined from top (lower-precedence) to bottom (higher-precedence). This is used to create a precedence table, associating each operator token with a precedence level.

In the same precedence table, operator and expression tokens are also associated with either a *prefix* parse function (to be used where the beginning of an expression is expected), an *infix* parse function (to be used where a right-hand operand of an expression also is expected), or both.

The precedence table below shows the entries for some arithmetic operators as well as for a number token.

| Token Type   | Prefix Function | Infix Function | Precedence
|:-------------|:----------------|:---------------|:--------------------|
| TOKEN_MINUS  | parse_unary     | parse_binary   | PRECEDENCE_TERM (6)
| TOKEN_PLUS   | -               | parse_binary   | PRECEDENCE_TERM (6)
| TOKEN_SLASH  | -               | parse_binary   | PRECEDENCE_FACTOR (7)
| TOKEN_STAR   | -               | parse_binary   | PRECEDENCE_FACTOR (7)
| TOKEN_NUMBER | parse_number    | -              | -

### Illustration

Source code:

```
1.2 + 3 * 4 / -5
```

When the parser encounters the token representing `*`, it should recursively keep parsing the next expression since the precedence of `*` is greater than that of `+`. Although, when it encounters `/`, it should return (by recursively unwinding) to the binary `*` expression and write the bytecode instruction for evaluating `3 * 4` before proceeding with parsing `/` since the precedence of `/` is equal to, not greater than, that of `*`.

Parsing based on precedence levels ensures that expressions are evaluated in the expected order, with higher-precedence operators first. It also allows enforcing operator associativity in order for same-level precedence operators to either be evaluated from left-to-right (such as the binary arithmetic operators) or right-to-left (such as the unary operators).

The parsing of the above source code example is hence conceptually represented as the below parsing tree, where lower-precedence operators appear higher up, and bottom nodes are evaluated first. As each expression is parsed (as indicated by the arrows) the operator is applied as the recursion unwinds, caused by encountering an operator with a precedence not high enough to proceed parsing.

![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-full.svg)

To get a more detailed walk-through of the parser's steps when parsing this example, see [Example: Arithmetic](#example-arithmetic).

> [!NOTE]
> Do note that the above parsing tree is merely conceptual. Since the Thusly compiler only does one pass, there is no abstract syntax tree created and traversed. Bytecode is written as the statements and expressions are parsed, but the evaluation order (performed later by the VM) will coincide with this conceptual tree.

## Constant Pool

A bytecode instruction to load a constant only has a certain number of bytes to represent the constant. Currently, Thusly supports one such instruction with 1 byte for the constant operand. But since strings, for instance, may be of arbitrary size, they are instead stored in a constant pool, allowing the bytecode instructions to refer to an address rather than the constant value itself. (As a side note, all strings are *interned* which you can read more about once that documentation is ready.)

Hence, when parsing literals of varying size, such as strings, as well as literals of fixed size, such as numbers (the underlying type for all Thusly numbers are C `double`), they get added to a constant pool. The callee function for adding the constant returns the address of the constant which the compiler then uses to write the bytecode instruction.

## Walk-Through of Examples

These examples demonstrate some of the details of the parser's and compiler's steps when processing a token.

> [!TIP]
> To more easily follow along, you can first read the overviews of Thusly's [parsing strategy](#top-down-operator-precedence-parsing) and [bytecode format](./bytecode.md).

* Examples:
  * [Arithmetic](#example-arithmetic)

### Example: Arithmetic

**Source code:**

```
1.2 + 3 * 4 / -5
```

**Tokens generated by the tokenizer:**

![Thusly generated tokens](../media/thusly-design-example-arithmetic-tokens.svg)

**Parsing process:**

**Token #1** (`1.2`):

```
1.2
 ^
```

1. The parser tells the tokenizer to generate and return the current token (`1.2`), which the parser now stores as `current`.
1. Since the parser expects the current token to be the beginning of an expression, it gets the *prefix* function (`parse_number`) associated with `TOKEN_NUMBER` in the [precedence table](#top-down-operator-precedence-parsing).
1. `parse_number` converts the lexeme `"1.2"` to the double `1.2` and in turn wraps it in a `ThuslyValue`.
1. The value is added to the constant pool at index 0.
1. The bytecode instruction is written:

    ```
    OP_CONSTANT 0
    ```

* **Current state:**
  * Constant pool:

    |        | Index 0 |
    |:-------|:-------:|
    | Value  | 1.2     |

  * Bytecode:

    ```
    OP_CONSTANT 0
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-01.svg)

**Token #2** (`+`):

```
1.2 +
    ^
```

1. Since `+` is the first operator encountered, the precedence of `+` is compared to the lowest possible precedence level.
1. Since the precedence of `+` is greater than the lowest, `current` is updated by advancing to the next token generated  (its right-hand side), and since the parser expects the operator to be an infix operator, it gets the *infix* function (`parse_binary`) associated with `TOKEN_PLUS` in the precedence table.
1. `parse_binary` recursively continues parsing the expression now using a minimum precedence level set to "the precedence of `+` + 1", which will be compared against when the next operator is encountered. If the minimum precedence is not incremented and the next operator is, for instance, a `+` or `-`, then those expressions will continue being parsed, mistakenly causing right-associativity. For the binary arithmetic operators, the parser enforces left-associativity by incrementing the minimum precedence before proceeding parsing the subsequent expression.

**Token #3** (`3`):

```
1.2 + 3
      ^
```

1. Since the parser now expects the current token to be the beginning of an expression, it gets the *prefix* function (`parse_number`) associated with `TOKEN_NUMBER` in the precedence table.
1. `parse_number` converts the lexeme `"3"` to the double `3` and in turn wraps it in a `ThuslyValue`.
1. The value is added to the constant pool at index 1.
1. The bytecode instruction is written:

    ```
    OP_CONSTANT 1
    ```

* **Current state:**
  * Constant pool:

    |        | Index 0 | Index 1 |
    |:-------|:-------:|:-------:|
    | Value  | 1.2     | 3       |

  * Bytecode:

    ```
    OP_CONSTANT 0
    OP_CONSTANT 1
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-02.svg)

**Token #4** (`*`):

```
1.2 + 3 *
        ^
```

1. Since the precedence of `*` is greater than `+` (hence satisfies the minimum "precedence of `+` + 1"), `current` is updated by advancing to the next token generated (its right-hand side), and since the parser expects the operator to be an infix operator, it gets the *infix* function (`parse_binary`) associated with `TOKEN_STAR` in the precedence table.
1. `parse_binary` recursively continues parsing the expression now using a minimum precedence level set to "the precedence of `*` + 1", which will be compared against when the next operator is encountered.

**Token #5** (`4`):

```
1.2 + 3 * 4
          ^
```

1. Since the parser now expects the current token to be the beginning of an expression, it gets the *prefix* function (`parse_number`) associated with `TOKEN_NUMBER` in the precedence table.
1. `parse_number` converts the lexeme `"4"` to the double `4` and in turn wraps it in a `ThuslyValue`.
1. The value is added to the constant pool at index 2.
1. The bytecode instruction is written:

    ```
    OP_CONSTANT 2
    ```

* **Current state:**
  * Constant pool:

    |        | Index 0 | Index 1 | Index 2 |
    |:-------|:-------:|:-------:|:-------:|
    | Value  | 1.2     | 3       | 4       |

  * Bytecode:

    ```
    OP_CONSTANT 0
    OP_CONSTANT 1
    OP_CONSTANT 2
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-03.svg)

**Token #6** (`/`):

```
1.2 + 3 * 4 /
            ^
```

1. Since the precedence of `/` is equal to `*` (hence does not satisfy the minimum "precedence of `*` + 1"), the recursive calls unwind to where `parse_binary` was parsing the right-hand expression of the `*` operator.
1. Since both the left and right operands of `*` have now been parsed, the bytecode instruction is written:

    ```
    OP_MULTIPLY
    ```

1. The recursion continues unwinding to where the `current` operator's (now `/`) precedence is compared against that of `+`.
1. Since the precedence of `/` is greater than `+` (hence satisfies the minimum "precedence of `+` + 1"), `current` is updated by advancing to the next token generated (its right-hand side), and since the parser expects the operator to be an infix operator, it gets the *infix* function (`parse_binary`) associated with `TOKEN_SLASH` in the precedence table.
1. `parse_binary` recursively continues parsing the expression now using a minimum precedence level set to "the precedence of `/` + 1", which will be compared against when the next operator is encountered.

* **Current state:**
  * Constant pool:

    |        | Index 0 | Index 1 | Index 2 |
    |:-------|:-------:|:-------:|:-------:|
    | Value  | 1.2     | 3       | 4       |
 
  * Bytecode:

    ```
    OP_CONSTANT 0
    OP_CONSTANT 1
    OP_CONSTANT 2
    OP_MULTIPLY
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-04.svg)

**Token #7** (`-`):

```
1.2 + 3 * 4 / -
              ^
```

1. Since the parser now expects the current token to be the beginning of an expression, it gets the *prefix* function (`parse_unary`) associated with `TOKEN_MINUS` in the precedence table.
1. `parse_unary` recursively continues parsing the expression now using a minimum precedence level set to "the precedence of unary `-`", which will be compared against when the next operator is encountered. Note that, unlike the binary arithmetic operators, the minimum precedence for parsing the right-hand side of the unary negation operator is the same precedence level as its operator. Hence, it is *not* incremented by 1. This enforces right-associativity in order for the expressions to be evaluated from right to left.

**Token #8** (`5`):

```
1.2 + 3 * 4 / -5
               ^
```

1. Since the parser now expects the current token to be the beginning of an expression, it gets the *prefix* function (`parse_number`) associated with `TOKEN_NUMBER` in the precedence table.
1. `parse_number` converts the lexeme `"5"` to the double `5` and in turn wraps it in a `ThuslyValue`.
1. The value is added to the constant pool at index 3.
1. The bytecode instruction is written:

    ```
    OP_CONSTANT 3
    ```

* **Current state:**
  * Constant pool:

    |        | Index 0 | Index 1 | Index 2 | Index 3 |
    |:-------|:-------:|:-------:|:-------:|:-------:|
    | Value  | 1.2     | 3       | 4       | 5       |

  * Bytecode:

    ```
    OP_CONSTANT 0
    OP_CONSTANT 1
    OP_CONSTANT 2
    OP_MULTIPLY
    OP_CONSTANT 3
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-05.svg)

**Token #9** (`EOF`, end of file):

```
1.2 + 3 * 4 / -5
                 ^
```

1. Since the end has been detected, the recursive calls unwind to where `parse_unary` was parsing the right-hand expression of the `-` operator.
1. Since the right operand of `-` have now been parsed, the bytecode instruction is written:

    ```
    OP_NEGATE
    ```

1. The recursion continues unwinding to where `parse_binary` was parsing the right-hand expression of the `/` operator.
1. Since both the left and right operands of `/` have now been parsed, the bytecode instruction is written:

    ```
    OP_DIVIDE
    ```

1. The recursion continues unwinding to where `parse_binary` was parsing the right-hand expression of the `+` operator.
1. Since both the left and right operands of `+` have now been parsed, the bytecode instruction is written:

    ```
    OP_ADD
    ```

* **Current state:**
  * Constant pool:

    |        | Index 0 | Index 1 | Index 2 | Index 3 |
    |:-------|:-------:|:-------:|:-------:|:-------:|
    | Value  | 1.2     | 3       | 4       | 5       |

  * Bytecode:

    ```
    OP_CONSTANT 0
    OP_CONSTANT 1
    OP_CONSTANT 2
    OP_MULTIPLY
    OP_CONSTANT 3
    OP_NEGATE
    OP_DIVIDE
    OP_ADD
    ```

  * Conceptual parsing tree:

    ![Thusly conceptual parsing tree example](../media/thusly-design-example-arithmetic-parsing-tree-06.svg)
