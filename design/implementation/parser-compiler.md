# Thusly Design - Parser & Compiler

## Table of Contents

> **TODO:** INSERT TABLE OF CONTENTS

## Abstract

> **TODO:** INSERT DIAGRAM

The parser and the compiler work in tandem to parse the tokens generated by the tokenizer and write the corresponding bytecode instructions in the correct order based on the precedence of the operators used.

The parser performs syntactic analysis to ensure coherence with the specified [grammar](../grammar.txt) as well as semantic analysis and variable resolution.

All steps are performed in a single pass.

## Top-Down Operator Precedence Parsing

The parser parses statements and expressions recursively starting from the top (expressions using lower-precedence operators) to bottom (expressions using higher-precedence operators).

Each production (or definition) of an expression rule in the Thusly grammar always either calls itself (same-level precedence) or a rule of higher precedence. Thus, it is defined from top (lower-precedence) to bottom (higher-precedence). This is used to create a precedence table, associating each operator token with a precedence level.

In the same precedence table, operator and expression tokens are also associated with either a *prefix* parse function (to be used where the beginning of an expression is expected), an *infix* parse function (to be used where a right-hand operand of an expression also is expected), or both.

The precedence table below shows the entries for some arithmetic operators as well as for a number token.

> **TODO:** DRAW PRECEDENCE TABLE

**Example illustration:**

Source code:

```
1.2 + 3 * 4 / -5
```

When the parser encounters the token representing `*`, it should recursively keep parsing the next expression since the precedence of `*` is greater than that of `+`. Although, when it encounters `/`, it should return (by recursively unwinding) to the binary `*` expression and write the bytecode instruction for evaluating `3 * 4` before proceeding with parsing `/`.

This ensures that expressions are evaluated in the expected order, with higher-precedence operators first, and left-to-right for same-level-precedence operators in the case of left-associative operators such as the arithmetic ones.

The parsing of the above source code example is hence conceptually represented as the below parsing tree, where lower-precedence operators appear higher up, and bottom nodes are evaluated first. As each expression is parsed (as indicated by the arrows) the operator is applied as the recursion unwinds, caused by encountering an operator with a precedence not high enough to proceed parsing.

> **TODO:** INSERT DIAGRAM

> [!NOTE]
> Do note that the above parsing tree is merely conceptual. Since the Thusly compiler only does one pass, there is no abstract syntax tree created and traversed. Bytecode is written as the statements and expressions are parsed, but the evaluation order (performed later by the VM) will coincide with this conceptual tree.

## Constant Pool

A bytecode instruction to load a constant only has a certain number of bytes to represent the constant. Currently, Thusly supports one such instruction with 1 byte for the constant operand. But since strings, for instance, may be of arbitrary size, they are instead stored in a constant pool, allowing the bytecode instructions to refer to an address rather than the constant value itself.

Hence, when parsing literals of varying size, such as strings, as well as literals of fixed size, such as numbers (all Thusly numbers are C `double`s), they get added to a constant pool. The callee function for adding the constant returns the address of the constant which the compiler then uses to write the bytecode instruction.
